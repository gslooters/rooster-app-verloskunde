# üéØ DRAAD407: IMPLEMENTATIE-OPDRACHT
## Real-Time per-Assignment Database Writes voor AFL

**Datum:** 7 januari 2026
**Status:** READY FOR IMPLEMENTATION
**Prioriteit:** HOOG - Core business logic
**Scope:** DirectWriteEngine + AFL Integration

---

## üìã INHOUD

1. [Context & Achtergrond](#context--achtergrond)
2. [Probleemstelling](#probleemstelling)
3. [Oplossingsontwerp](#oplossingsontwerp)
4. [Implementatie-stappen](#implementatie-stappen)
5. [Code-wijzigingen detail](#code-wijzigingen-detail)
6. [Testing-checklist](#testing-checklist)
7. [Deployment-checklist](#deployment-checklist)

---

## Context & Achtergrond

### Situatie

**Manual Planning (roosterbeheer):** ‚úÖ WERKT CORRECT
- Via `assignmentHandlers.ts` ‚Üí `createAssignment()`
- INSERT roster_assignments met `roster_period_staffing_dagdelen_id`
- Trigger fires automatisch ‚Üí `invulling` +1
- Result: Beide database updates synchroon, atomair

**AFL (Autofill):** ‚ùå ONVOLLEDIG
- Via `write-engine.ts` ‚Üí Batch UPDATE
- UPDATE doet trigger NIET vuren
- Invulling updates gebeurt achteraf, asynchron, non-atomair
- Result: Statistieken onvolledig, data inconsistent

### Gewenste Eindtoestand

**AFL moet zich gedragen als "manual planning":**
- Real-time per-assignment writes (niet batch)
- INSERT voor new assignments ‚Üí trigger auto-increments invulling
- UPDATE voor existing assignments + manual invulling+1
- 100% atomair: beide writes lukken OF beide falen
- Direct tracking via `roster_period_staffing_dagdelen_id`

### Database Info

**Tabel:** `roster_period_staffing_dagdelen`
```
id (UUID) - PK
roster_id
date
dagdeel (O, M, N)
service_id
team
aantal (required)
invulling (counter: 0..aantal) ‚Üê CRITIEK VELD
status, issystem, created_at, updated_at
```

**Tabel:** `roster_assignments`
```
id (UUID) - PK
roster_id
employee_id
date
dagdeel
service_id
team
status (0=inactive, 1=active)
roster_period_staffing_dagdelen_id (FK) ‚Üê [DRAAD369]
ort_run_id (tracking)
source (manual, autofill, pre_planning)
created_at, updated_at
```

**Trigger:** `trigger_rps_dagdelen_updated_at`
```
Event: UPDATE on roster_period_staffing_dagdelen
Function: update_rps_dagdelen_updated_at()
Status: ‚úÖ OPERATIONEEL
```

---

## Probleemstelling

### PROBLEEM 1: Batch UPDATE triggert geen invulling-logic

**Huidi code (write-engine.ts):**
```typescript
await supabase
  .from('roster_assignments')
  .update({ service_id, status, roster_period_staffing_dagdelen_id }) // UPDATE
  .eq('id', assignmentId);
```

**Issue:**
- UPDATE fires NOT de trigger die invulling +1 doet
- Trigger is ingesteld voor INSERT, niet voor UPDATE op roster_assignments
- Invulling moet handmatig worden bijgewerkt (wat nu fout gaat)

### PROBLEEM 2: Async invulling counter updates

**Huidi code (write-engine.ts `updateInvullingCounters()`):**
```typescript
for (const slot of modified_slots) {
  const variantId = await this.getVariantId(...); // ‚Üê VEEL QUERIES
  variant_counts.set(variantId, (variant_counts.get(variantId) || 0) + 1);
}

const results = await Promise.allSettled(update_promises); // ‚Üê PARTIAL FAILURES
```

**Issues:**
- N √ó getVariantId() queries (1 per slot) = performance issue
- Promise.allSettled() kan deels falen ‚Üí partial writes
- Non-atomair: assignment created, invulling update fails = data corruption

### PROBLEEM 3: Architectural mismatch

| Aspekt | Manual Planning | AFL |
|--------|---|---|
| Write type | INSERT | UPDATE |
| Trigger firing | ‚úÖ YES | ‚ùå NO |
| Invulling update | Automatisch | Handmatig, async |
| Atomicity | ‚úÖ GARANTIE | ‚ùå NO |
| Pattern | Per-assignment | Batch eind |

---

## Oplossingsontwerp

### Core Concept: DirectWriteEngine

Nieuw module `src/lib/afl/direct-write-engine.ts` dat per-assignment direct naar database schrijft, net als roosterbeheer.

### Twee Scenario's

**SCENARIO A: NEW ASSIGNMENT**
```
INSERT roster_assignments (status=1, service_id, variant_id)
    ‚Üì
Trigger fires
    ‚Üì
Auto-increments invulling ‚úÖ
```

**SCENARIO B: EXISTING ASSIGNMENT (update van bestaande)
```
UPDATE roster_assignments (service_id, variant_id, status=0‚Üí1)
    ‚Üì
Manually: UPDATE invulling +1
    ‚Üì
Both succeed OR both fail (atomair)
```

### Architecture

```
AFL Solve Engine
    ‚Üì
Phase 3: Generate Assignments
    ‚Üì
Phase 4A: Direct Write (NEW)
    ‚îú‚îÄ Preload variant IDs (1 query)
    ‚îú‚îÄ Per-assignment direct write
    ‚îÇ  ‚îú‚îÄ Scenario A: INSERT (trigger auto-increments)
    ‚îÇ  ‚îî‚îÄ Scenario B: UPDATE + manual invulling
    ‚îî‚îÄ Result: Written count
    ‚Üì
Phase 4B: Finalize
    ‚îú‚îÄ Update rooster status
    ‚îú‚îÄ Generate report
    ‚îî‚îÄ No more invulling updates!
```

---

## Implementatie-stappen

### STAP 1: Create DirectWriteEngine (NIEUW FILE)

**File:** `src/lib/afl/direct-write-engine.ts`
**Grootte:** ~450 lines
**Status:** NIEUW

**Classes/Functions:**
- `DirectWriteEngine` class
- `writeSingleAssignmentDirect()` - main entry point
- `insertNewAssignment()` - scenario A
- `updateExistingAssignment()` - scenario B
- `findExistingAssignment()` - helper
- `writeBatchAssignmentsDirect()` - batch wrapper
- `getDirectWriteEngine()` - singleton

**Key Features:**
- Per-assignment error handling
- 100ms delay after INSERT for trigger execution
- Manual invulling update for UPDATE scenario
- Comprehensive logging [DRAAD407]
- Type-safe team field handling

---

### STAP 2: Update SolveEngine

**File:** `src/lib/afl/solve-engine.ts`
**Lines to modify:** ~50 (around phase 4)
**Type:** MODIFY EXISTING

**Wijzigingen:**
1. Import DirectWriteEngine
2. Replace old Phase 4 (batch update) with:
   - Phase 4A: Direct write via DirectWriteEngine
   - Phase 4B: Finalize (rooster status only)
3. Add `preloadVariantIds()` helper method
4. Remove call to old WriteEngine phase 4

**Before:**
```typescript
// Old Phase 4
const updated_count = await this.batchUpdateAssignments(...);
const invulling_updates = await this.updateInvullingCounters(...);
await this.updateRosterStatus(...);
```

**After:**
```typescript
// New Phase 4A: Direct write
const variantIdMap = await this.preloadVariantIds(rosterId, assignments);
const writeResult = await directWriter.writeBatchAssignmentsDirect(
  rosterId, assignments, variantIdMap
);

// Phase 4B: Finalize
await this.finalizeAflRun(rosterId, ort_run_id);
```

---

### STAP 3: Clean up WriteEngine

**File:** `src/lib/afl/write-engine.ts`
**Lines to remove:** ~150 (updateInvullingCounters method + related code)
**Type:** DELETE CODE

**Verwijderen:**
1. `updateInvullingCounters()` method (volledige ~100 lines)
2. `getVariantId()` method (duplicate, now in DirectWriteEngine)
3. Call to `updateInvullingCounters()` in `writeModifiedSlots()`
4. Related comments/documentation

**Keep:**
- `updateRosterStatus()` (still needed for finalize)
- `batchUpdateAssignments()` structure (if used elsewhere)
- Other helper methods

**IMPORTANT:** Zorg dat WriteEngine NIET meer wordt gebruikt voor:
- Variant ID lookup (now in DirectWriteEngine)
- Invulling counter updates (now in DirectWriteEngine)
- Direct assignment writes (now in DirectWriteEngine)

---

### STAP 4: Update Type Definitions

**File:** `src/lib/afl/types.ts`
**Add:** DirectWrite-specific types

**Toevoegen:**
```typescript
export interface AflAssignmentRecord {
  id: string;
  employee_id: string;
  date: string; // ISO format
  dagdeel: string;
  service_id: string;
  team?: string;
  status: 0 | 1 | 2 | 3;
  ort_run_id?: string;
}

export interface DirectWriteResult {
  success: boolean;
  assignment_id?: string;
  invulling_updated?: boolean;
  error?: string;
}

export interface BatchDirectWriteResult {
  success: boolean;
  written_count: number;
  failed_count: number;
  errors: string[];
}
```

---

## Code-wijzigingen detail

### FILE 1: src/lib/afl/direct-write-engine.ts (NEW)

**Template geleverd in volgende stap**

**Key Methods:**

#### `writeSingleAssignmentDirect()`
```typescript
public async writeSingleAssignmentDirect(
  assignment: AflAssignmentRecord,
  rosterId: string,
  variantId: string
): Promise<DirectWriteResult>
```

**Flow:**
1. Validate variant exists
2. Check if assignment exists
3. IF NOT: insertNewAssignment()
4. IF YES: updateExistingAssignment()
5. Return result

#### `insertNewAssignment()`
```typescript
private async insertNewAssignment(
  assignment: AflAssignmentRecord,
  rosterId: string,
  variantId: string
): Promise<DirectWriteResult>
```

**Flow:**
1. INSERT roster_assignments (status=1, all fields)
2. Include: roster_period_staffing_dagdelen_id
3. Include: ort_run_id for tracking
4. Source: 'autofill'
5. Wait 100ms (trigger execution)
6. Return: { success: true, assignment_id, invulling_updated: true }

#### `updateExistingAssignment()`
```typescript
private async updateExistingAssignment(
  assignmentId: string,
  assignment: AflAssignmentRecord,
  newVariantId: string,
  currentInvulling: number
): Promise<DirectWriteResult>
```

**Flow:**
1. UPDATE roster_assignments (service_id, variant_id, status)
2. Check: success?
3. Manual UPDATE invulling: currentInvulling + 1
4. Check: success?
5. IF both success: return { success: true }
6. IF any fail: return { success: false, error: "..." }

---

### FILE 2: src/lib/afl/solve-engine.ts (MODIFY)

**Import toevoegen:**
```typescript
import { DirectWriteEngine, getDirectWriteEngine } from './direct-write-engine';
```

**Method toevoegen:**
```typescript
private async preloadVariantIds(
  rosterId: string,
  assignments: AflAssignmentRecord[]
): Promise<Map<string, string>>
```

**Flow:**
1. Collect unique (date, dagdeel, service_id, team) combinations
2. Single query: SELECT all roster_period_staffing_dagdelen for rosterId
3. Build Map<key, id>
4. Return map

**Phase 4 wijzigen:**

**BEFORE:**
```typescript
// OLD Phase 4
const modified_slots = workbestand_planning.filter(slot => slot.is_modified);
const update_payloads = await this.buildUpdatePayloadsWithVariantIds(...);
const updated_count = await this.batchUpdateAssignments(...);
const invulling_updates = await this.updateInvullingCounters(...);
await this.updateRosterStatus(...);
```

**AFTER:**
```typescript
// NEW Phase 4A: Direct Write
const assignments = await this.phase3_generateAssignments(...);
const directWriter = getDirectWriteEngine();
const variantIdMap = await this.preloadVariantIds(rosterId, assignments);
const writeResult = await directWriter.writeBatchAssignmentsDirect(
  rosterId, assignments, variantIdMap
);

if (!writeResult.success) {
  return { success: false, error: `Write failed: ${writeResult.errors.join('; ')}` };
}

// Phase 4B: Finalize
await this.updateRosterStatus(rosterId, ort_run_id);
await this.generateAflReport(rosterId, ort_run_id);
```

---

### FILE 3: src/lib/afl/write-engine.ts (CLEANUP)

**Verwijderen:**
1. Volledige `updateInvullingCounters()` method
2. Volledige `getVariantId()` method
3. Call naar `updateInvullingCounters()` in `writeModifiedSlots()`
4. Related helper methods

**Houden:**
1. Class definition
2. `updateRosterStatus()` method (noch nodig in finalize)
3. Other helper methods (if used elsewhere)

---

### FILE 4: src/lib/afl/types.ts (ADD)

**Toevoegen:**
```typescript
// [DRAAD407] DirectWrite types
export interface AflAssignmentRecord {
  id: string;
  employee_id: string;
  date: string;
  dagdeel: string;
  service_id: string;
  team?: string;
  status: 0 | 1 | 2 | 3;
  ort_run_id?: string;
}

export interface DirectWriteResult {
  success: boolean;
  assignment_id?: string;
  invulling_updated?: boolean;
  error?: string;
}

export interface BatchDirectWriteResult {
  success: boolean;
  written_count: number;
  failed_count: number;
  errors: string[];
}
```

---

## Testing-checklist

### Unit Tests

**File:** `src/lib/afl/direct-write-engine.test.ts`

#### Test Scenario A: INSERT New Assignment
```typescript
test('SCENARIO A: INSERT new assignment triggers invulling auto-increment')
// Setup: Empty assignment
// Action: writeSingleAssignmentDirect()
// Assert: roster_assignments.id exists
// Assert: invulling in roster_period_staffing_dagdelen incremented
```

#### Test Scenario B: UPDATE Existing Assignment
```typescript
test('SCENARIO B: UPDATE existing assignment with manual invulling increment')
// Setup: Existing assignment (status=0, no service_id)
// Action: writeSingleAssignmentDirect()
// Assert: assignment.service_id updated
// Assert: assignment.status = 1
// Assert: invulling manually incremented
```

#### Test Error Handling
```typescript
test('UPDATE assignment success, invulling update failure returns error')
// Setup: Existing assignment, invalid variant_id
// Action: writeSingleAssignmentDirect()
// Assert: success = false
// Assert: error message contains "invulling"
```

### Integration Tests

**File:** `src/lib/afl/solve-engine.test.ts` (MODIFY)

#### Test Variant ID Preload
```typescript
test('preloadVariantIds returns complete map for all combinations')
// Setup: 5 assignments, 3 unique variants
// Action: preloadVariantIds()
// Assert: map.size = 3
// Assert: all variant IDs resolve
```

#### Test Full AFL Run
```typescript
test('Complete AFL run writes all assignments with invulling updates')
// Setup: Full roster with 10+ assignments
// Action: executeAflPhases()
// Assert: All assignments written
// Assert: All invulling counters updated correctly
// Assert: No partial writes
```

### Manual QA Checklist

- [ ] AFL run completes without errors
- [ ] roster_assignments records created with:
  - `status=1` ‚úì
  - `service_id` populated ‚úì
  - `roster_period_staffing_dagdelen_id` populated ‚úì
  - `ort_run_id` for tracking ‚úì
  - `source='autofill'` ‚úì
- [ ] roster_period_staffing_dagdelen.invulling incremented correctly
- [ ] Logs show [DRAAD407] markers for all writes
- [ ] Performance: AFL run completes in <5s
- [ ] No duplicates or missing assignments
- [ ] Report accurately reflects written count

---

## Deployment-checklist

### Pre-Deployment

- [ ] All tests passing (unit + integration)
- [ ] Code review completed
- [ ] DirectWriteEngine logging reviewed
- [ ] Variant ID preload performance tested
- [ ] Error messages user-friendly (Dutch)
- [ ] Type safety verified (no `any` types)
- [ ] Backward compatibility verified
  - [ ] Manual planning still works
  - [ ] Roosterbeheer not affected
  - [ ] Other AFL phases not affected

### Deployment

1. **Create branch:**
   ```
   draad407-direct-write-engine
   ```

2. **Commit sequence:**
   - Commit 1: Add direct-write-engine.ts (new file)
   - Commit 2: Update solve-engine.ts (integration)
   - Commit 3: Clean up write-engine.ts (removals)
   - Commit 4: Add types to types.ts
   - Commit 5: Add tests

3. **PR Review:**
   - [ ] All files reviewed
   - [ ] Tests reviewed
   - [ ] Performance impact assessed
   - [ ] Architecture aligned

4. **Merge to main:**
   - Squash or keep commits? ‚Üí **Keep commits** (clear history)
   - Delete branch after merge

5. **Railway deployment:**
   - [ ] Automatic deploy on main merge
   - [ ] Verify logs for [DRAAD407] markers
   - [ ] Test full AFL run in production
   - [ ] Monitor for errors

### Post-Deployment

- [ ] Monitor AFL logs for [DRAAD407] entries
- [ ] Check roster_period_staffing_dagdelen.invulling values
- [ ] Verify statistics are now accurate
- [ ] Document changes in release notes

---

## Reference Implementatie

### Direct Write Engine Pseudocode

```typescript
class DirectWriteEngine {
  
  async writeSingleAssignmentDirect(
    assignment: AflAssignmentRecord,
    rosterId: string,
    variantId: string
  ): Promise<DirectWriteResult> {
    
    // 1. Validate variant
    const variant = await supabase
      .from('roster_period_staffing_dagdelen')
      .select('id, invulling, aantal')
      .eq('id', variantId)
      .single();
    
    if (!variant) return { success: false, error: "..." };
    
    // 2. Check if assignment exists
    const existing = await this.findExistingAssignment(...);
    
    // 3. INSERT or UPDATE
    if (!existing) {
      return await this.insertNewAssignment(...);
    } else {
      return await this.updateExistingAssignment(...);
    }
  }
  
  private async insertNewAssignment(...): Promise<DirectWriteResult> {
    // INSERT roster_assignments
    const { data, error } = await supabase
      .from('roster_assignments')
      .insert([{ ... roster_period_staffing_dagdelen_id ... }])
      .select('id')
      .single();
    
    if (error) return { success: false, error: "..." };
    
    // Wait for trigger
    await this.delay(100);
    
    return { success: true, assignment_id: data.id, invulling_updated: true };
  }
  
  private async updateExistingAssignment(...): Promise<DirectWriteResult> {
    // UPDATE assignment
    const updateResult = await supabase
      .from('roster_assignments')
      .update({ service_id, status, roster_period_staffing_dagdelen_id })
      .eq('id', assignmentId);
    
    if (updateResult.error) return { success: false, error: "..." };
    
    // MANUALLY update invulling
    const newInvulling = currentInvulling + 1;
    const invullingResult = await supabase
      .from('roster_period_staffing_dagdelen')
      .update({ invulling: newInvulling })
      .eq('id', variantId);
    
    if (invullingResult.error) {
      return { success: false, error: "Assignment OK but invulling failed" };
    }
    
    return { success: true, assignment_id: assignmentId, invulling_updated: true };
  }
}
```

---

## Troubleshooting Guide

### Issue: Invulling not incrementing

**Symptom:** Assignment created, invulling stays 0

**Diagnose:**
1. Check trigger exists: `SELECT * FROM pg_triggers WHERE tgname LIKE '%rps%'`
2. Check trigger function: `SELECT * FROM pg_proc WHERE proname LIKE '%rps%'`
3. Check logs for [DRAAD407] errors
4. Verify variant_id is correct in assignment

**Fix:**
- Increase delay from 100ms to 200ms in `insertNewAssignment()`
- Add explicit logging before/after trigger-dependent code
- Verify trigger fires: add test UPDATE to roster_period_staffing_dagdelen

### Issue: Partial writes (assignment created, invulling failed)

**Symptom:** Assignments exist but invulling counters wrong

**Diagnose:**
1. Check logs for "Assignment OK but invulling failed" messages
2. Count assignments vs invulling sums
3. Find mismatched records

**Fix:**
- Add transaction wrapper (PostgreSQL BEGIN/ROLLBACK)
- Or: Accept partial writes, add cleanup task to fix invulling

### Issue: Performance degradation

**Symptom:** AFL run takes >10s instead of <5s

**Diagnose:**
1. Check variant ID preload query performance
2. Count database queries
3. Check network latency

**Fix:**
- Optimize preloadVariantIds() query with indexes
- Batch 50 assignments per transaction
- Add query caching

---

## Success Criteria

‚úÖ **Functional:**
- [ ] AFL writes assignments real-time per-assignment
- [ ] invulling counters update correctly
- [ ] 100% atomicity: both writes succeed or both fail
- [ ] No partial writes
- [ ] roster_period_staffing_dagdelen_id properly set

‚úÖ **Performance:**
- [ ] AFL run <5s (same or better than before)
- [ ] Variant ID preload <100ms
- [ ] Per-assignment write <100ms average

‚úÖ **Quality:**
- [ ] All tests passing
- [ ] Comprehensive logging [DRAAD407]
- [ ] Error messages clear (Dutch)
- [ ] Code reviewed and approved

‚úÖ **Compatibility:**
- [ ] Manual planning still works
- [ ] All existing tests pass
- [ ] Backward compatible

---

## Links & References

- **Codebase:** https://github.com/gslooters/rooster-app-verloskunde
- **Related DRADs:** DRAAD369 (variant ID), DRAAD403B (fout fixes)
- **Database:** Supabase (PostgreSQL)
- **Type Definitions:** src/lib/afl/types.ts
- **Assignment Handlers:** src/lib/handlers/assignmentHandlers.ts (reference pattern)

---

## EINDE OPDRACHT

**Deze opdracht beschrijft de volledige implementatie van DRAAD407.**

**Volgende stap:** 
1. Create branch `draad407-direct-write-engine`
2. Implementeer stap-voor-stap
3. Voer tests uit
4. Create PR voor review

**Vragen/Issues:** Documenteer in DRAAD407-NOTES.md
