# ğŸš¨ DRAAD151B: KRITIEKE BEVINDING - WERKELIJKE ROOT CAUSE

**Status:** ğŸ”´ **BATCH UPSERT PATTERN WERKT NIET**
**Datum:** 2025-12-09 23:16 UTC
**Fout:** `[DRAAD150] Batch UPSERT failed: 1137/1137 slots`

---

## ğŸ’” WAT IS ER MIS GEGAAN MET DRAAD150

De DRAAD150 oplossing (batch UPSERT per slot) is **compleet MISLUKT**!

### Console Error
```
[DRAAD150] ORT resultaat: {error: '[DRAAD150] Batch UPSERT failed: 1137/1137 slots'}
failedSlots: 1137
successCount: 0
```

### Railway Logs (ALLE slots falen)
```
[DRAAD150] Slot upsert failed: duplicate key value violates unique constraint "roster_assignments_unique_key"
[DRAAD150] Slot upsert failed: duplicate key value violates unique constraint "roster_assignments_unique_key"
[DRAAD150] Slot upsert failed: duplicate key value violates unique constraint "roster_assignments_unique_key"
... (HERHAALD voor alle 1137 slots)
```

---

## ğŸ”´ DE WERKELIJKE ROOT CAUSE

### Uit Supabase Schema Analysis

```
tabel: roster_assignments

Kolom          | Constraint
â•¼â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
id             | PRIMARY KEY
roster_id      | FOREIGN KEY + (geen UNIQUE)
employee_id    | FOREIGN KEY + UNIQUE â† âš ï¸âš ï¸âš ï¸
date           | (geen UNIQUE)
dagdeel        | CHECK + UNIQUE â† âš ï¸âš ï¸âš ï¸
service_id     | FOREIGN KEY (NULLABLE)
status         | CHECK
```

### Het Kritieke Probleem

**De database has AFZONDERLIJKE UNIQUE constraints:**

1. **UNIQUE(employee_id)**
   - Betekent: Per medewerker kan SLECHTS 1 record bestaan
   - DRAAD150 probeert 1040 records per medewerker in te voegen
   - **CONFLICT GARANTIE:** Tweede record per employee FAALT

2. **UNIQUE(dagdeel)**
   - Betekent: Per dagdeel kan SLECHTS 1 record bestaan
   - DRAAD150 probeert meerdere records per dagdeel in te voegen
   - **CONFLICT GARANTIE:** Tweede record per dagdeel FAALT

### Waarom DRAAD150 100% Faalt

```
Slot 1: roster_X|emp_A|2025-12-10|O
  â†’ UPSERT record 1 (service: CARE)
  â†’ SUCCESS (first employee_id record)

Slot 2: roster_X|emp_A|2025-12-11|M  â† SAME employee_id!
  â†’ UPSERT record 2 (service: SPECIAL)
  â†’ FAILURE! UNIQUE(employee_id) violated
  â†’ "duplicate key value violates unique constraint"

Slot 3: roster_X|emp_B|2025-12-10|O  â† SAME dagdeel!
  â†’ UPSERT record 1 (service: CARE)
  â†’ FAILURE! UNIQUE(dagdeel) violated
  â†’ "duplicate key value violates unique constraint"
```

---

## ğŸ¤¦ WAT GING ER MIS MET DE VORIGE ANALYSE

### Draad150 Aanname

DRAD150 assumeerde:
- âœ… Batch UPSERT per slot zou conflicts voorkomen
- âœ… Primary key (id) zou unique zijn
- âŒ **MAAR VERGAT:** UNIQUE(employee_id) + UNIQUE(dagdeel) constraints!

### Waarom Het Niet Werkte

1. **Batch groepering** per slot:
   ```
   (roster_id|employee_id|date|dagdeel) â†’ assignments
   ```

2. **UPSERT logic:**
   ```typescript
   onConflict: 'id'  // Primary key only
   ```

3. **Probleem:**
   - Employee_id constraint NIET via `onConflict: 'id'` gehandeld
   - Dagdeel constraint NIET via `onConflict: 'id'` gehandeld
   - PostgreSQL: "Hey, employee_id moet uniek zijn!"
   - Boom. Fail.

---

## âœ… DE WERKELIJKE OPLOSSING

### De Harde Waarheid

Met de HUIDIGE database schema kan je **NOOIT** meer dan 1 record per employee en 1 record per dagdeel hebben!

### Twee Opties

#### Optie A: Database Schema WIJZIGEN (Aanbevolen)

**Stap 1: DROP oude constraints**
```sql
ALTER TABLE roster_assignments DROP CONSTRAINT roster_assignments_employee_id_unique;
ALTER TABLE roster_assignments DROP CONSTRAINT roster_assignments_dagdeel_unique;
```

**Stap 2: CREATE samengestelde constraint**
```sql
ALTER TABLE roster_assignments
ADD CONSTRAINT roster_assignments_unique_key 
UNIQUE(roster_id, employee_id, date, dagdeel, service_id);
```

**Impact:**
- âœ… Staat meerdere assignments per employee toe
- âœ… Staat meerdere assignments per dagdeel toe
- âœ… Staat meerdere diensten per slot toe
- âœ… DRAAD150 batch pattern zou DAN werken

#### Optie B: Application-Level Enforcement (Niet Ideaal)

Veranderen we de data VOOR we naar DB gaan:
- Merge duplicate employees â†’ single record
- Merge duplicate dagdelen â†’ single record
- UPSERT dan alleen die 1 record per combo

**Problemen:**
- Leidt tot dataverlies
- Tegen intuÃ¯tie roostersysteem
- Veel logica-overhead

---

## ğŸ¯ AANBEVELING: DRAAD152 DATABASE SCHEMA FIX

### Wat Te Doen

1. **In Supabase UI:**
   - SQL Editor openen
   - DROP de twee UNIQUE constraints
   - CREATE nieuwe composite constraint

2. **In Code (app/api/roster/solve/route.ts):**
   - BEHOUD DRAAD150 batch UPSERT logic
   - Voeg error handling toe voor betere diagnostics
   - Tests toevoegen

3. **Testing:**
   - Na schema fix: retry solver
   - Controleer logs voor "âœ… All X slots UPSERT successful"
   - Verifieer 1040 assignments in database

---

## ğŸ“‹ WAAROM GEEN SNELLE FIX MOGELIJK IS

### Database Design Flaw

De UNIQUE constraints zijn:
- âŒ Niet documented in code
- âŒ Niet te omzeilen via application logic
- âŒ Hard constraint op database level
- âœ… Alleen oplosbaar via schema wijziging

### Vorige Pogingen Waren Vergeefs

| Draad | Aanpak | Resultaat | Waarom Mislukt |
|-------|--------|-----------|----------------|
| DRAAD129-FIX4 | Deduplicatie fix | Logs zeggen "CLEAN" | Constraint check is later (bij UPSERT) |
| DRAAD149 | Type verificatie | Type is correct | Constraint niet gerelateerd aan type |
| DRAAD149B | Service ID in key | Dedup werkt perfect | Constraint check is bij UPSERT, niet dedup |
| DRAAD150 | Batch per slot | **ALLE slots falen** | Database constraints niet in batch logica meegenomen |

---

## ğŸš€ SCHEMA FIX PROCEDURE

### Stap 1: Backup (Veiligheid)
```sql
-- Maak backup van current assignments
CREATE TABLE roster_assignments_backup AS
SELECT * FROM roster_assignments;
```

### Stap 2: Drop Constraints
```sql
ALTER TABLE roster_assignments
DROP CONSTRAINT IF EXISTS roster_assignments_employee_id_key;

ALTER TABLE roster_assignments
DROP CONSTRAINT IF EXISTS roster_assignments_dagdeel_key;
```

### Stap 3: Create Composite Constraint
```sql
ALTER TABLE roster_assignments
ADD CONSTRAINT roster_assignments_unique_key
UNIQUE (roster_id, employee_id, date, dagdeel);
```

### Stap 4: Verify
```sql
-- Check constraints
\d roster_assignments

-- Should show:
-- "roster_assignments_unique_key" UNIQUE, btree (roster_id, employee_id, date, dagdeel)
```

---

## ğŸ“Š VERWACHTE RESULTATEN NA FIX

### Terug naar DRAAD150 Logic

Na schema wijziging:

```
SOLVER OUTPUT: 1137 assignments
  â†“
[DRAAD150] Grouping by slot (1365 slots)
  â†“
[DRAAD150] Processing slot 1: roster_X|emp_A|2025-12-10|O (1 assignment)
[DRAAD150] âœ… Slot upsert successful (1 items)
  â†“
[DRAAD150] Processing slot 2: roster_X|emp_A|2025-12-11|M (2 assignments same employee)
[DRAAD150] âœ… Slot upsert successful (2 items)
  â†“
... (1365 slots)
  â†“
[DRAAD150] âœ… All 1365 slots UPSERT successful (234ms)
  â†“
âœ… 1137 assignments persisted
âœ… Roster status: draft â†’ in_progress
```

---

## ğŸš¨ STATUS

- âŒ DRAAD150: Batch UPSERT pattern werkt NIET (alle slots falen)
- ğŸ”´ Root Cause: UNIQUE(employee_id) + UNIQUE(dagdeel) constraints
- ğŸ¯ Oplossing: Database schema wijziging nodig
- ğŸ“‹ Volgende: DRAAD152 - Schema fix implementation

---

_Gegeneerd: 2025-12-09T23:16:00Z_
_Lachwekkend en treurig tegelijk._
