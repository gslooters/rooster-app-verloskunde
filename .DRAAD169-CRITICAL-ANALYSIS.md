# üî¥ KRITIEKE ANALYSE: DRAAD 169 ORT TESTING FAILURE

**Datum:** 2025-12-12 22:43 CET  
**Dreiging:** ORT Solver werkt NIET - volledig falen in alle testen  
**Status:** üö® URGENT ANALYSE NODIG

---

## 1Ô∏è‚É£ BEVINDINGEN UIT UPLOADS

### A. Schone Rooster (Image 1) ‚úÖ
- **Status:** Voldoende capaciteit
- **Gegevens:**
  - Status 0 (ongeldig): 1211 slots
  - Status 1 (optimaal): 4 slots (!)
  - Status 3 (tekort): 252 slots
  - Status 2 (iets anders): 3 slots
  - **TOTAAL: 1470 slots**

**ERNSTIG PROBLEEM:** Van 1470 slots zijn er slechts 4 "optimaal"! 1211 "ongeldig" slots!

### B. Preplanning (Image 2) ‚úÖ
- 4 diensten ingevuld
- Schoon, leesbaar
- Lijkt klaar voor ORT

### C. ORT Run (Image 3) üî¥
- **Solver status:** Wordt niet duidelijk
- **Visuele weergave:** Diensten ZIJN ingevuld
- Maar: Geen bericht over "OPTIMAL" of "FEASIBLE"
- **Geen verdere info in message**

### D. Railway Logs (log-Railway.txt) üî¥
**KRITIEKE BEVINDINGEN:**

```
[SOLVER INITIALIZATION]
- solver2 service bootend...
- Python environment: OK
- OR-Tools importeerd: OK

[EERSTE RUN - FAALT]
- Model buildtime: 0.45s
- Constraint toevoeging: OK
- Objective definition: OK
- SOLVER STATUS: UNKNOWN ‚ùå

[REPEAT RUNS]
- Alle runs hebben UNKNOWN status
- Geen verandering in constraint logica
- Geen foutmeldingen, maar ook geen STATUS ‚úÖ
```

**KEY FINDING:** Logs tonen geen duidelijke "OPTIMAL" of "INFEASIBLE" - juist "UNKNOWN"

### E. Console Output (CONSOLE.txt) üî¥
```
[ERROR] Solver returned UNKNOWN status
[ERROR] No solution generated
[WARN] Model validation passed but solver timeout?
[ERROR] JSON output empty or malformed
```

**KRITIEK:** "UNKNOWN status" + "No solution" = **Solver loopt vast of timeout**

---

## 2Ô∏è‚É£ DIEPGAANDE ANALYSE: WAAROM FAALT DRAAD 168?

De DRAAD 168 "fixes" zijn:
1. **CORR-2:** Constraint 7 bevoegdheden check toevoeging
2. **CORR-3:** DIO+DIA bonus logica via AddBoolAnd

### ‚ùå WAAROM DIT NIET WERKT:

#### **PROBLEEM 1: Constraint 7 - Fundamentele Logic Error**

```python
# DRAAD 168 "FIX"
eligible_emps = [e for e in team_filtered 
               if staffing.service_id in self.employee_services.get(e.id, set())]

if not eligible_emps:
    logger.warning(f"[DRAAD168] CORR-2: No eligible employees")
    continue  # ‚Üê SKIPS CONSTRAINT ENTIRELY!
```

**FOUT:** Wanneer `not eligible_emps`, doet het solver:
- NIETS toevoegen aan model
- Constraint wordt OVERGESLAGEN
- **Model heeft DAN GEEN CONSTRAINTS VOOR DEZE STAFFING**
- Solver kan random assignments maken
- ‚ûú **LEADING TO INVALID SOLUTIONS**

**Correct zou zijn:**
- ALTIJD constraint toevoegen (zelfs als infeasible)
- Laat solver zelf bepalen infeasibility
- Current code = **SILENT FAILURE**

---

#### **PROBLEEM 2: AddBoolAnd Reification - Misused Pattern**

```python
# DRAAD 168 "FIX"
self.model.AddBoolAnd([dio_var, dia_var]).OnlyEnforceIf(koppel_var)
```

**FOUT:**
1. **AddBoolAnd ‚â† True constraint enforcment**
   - AddBoolAnd creates (dio_var & dia_var) = 1 expression
   - OnlyEnforceIf applies conditional logic WRONG
   
2. **Reification Issue:**
   - Should be: `koppel_var` ‚ü∫ `(dio_var ‚àß dia_var)`
   - Current: `If koppel_var Then (dio_var ‚àß dia_var)` = incomplete logic
   
3. **Solver Behavior:**
   - Solver can still set `koppel_var=FALSE` 
   - No contradiction when assignment differs
   - Bonus never triggers (SAME AS BEFORE)

**Correct would be:**
```python
# TRUE reification:
d1 = model.NewBoolVar('d1')
d2 = model.NewBoolVar('d2')
koppel = model.NewBoolVar('koppel')

# Both directions enforced:
model.Add(d1 + d2 == 2).OnlyEnforceIf(koppel)
model.Add(d1 + d2 < 2).OnlyEnforceIf(koppel.Not())
# NOW koppel is TRUE iff d1 & d2 both TRUE
```

Current DRAAD 168 code is **STILL WRONG** ‚ùå

---

## 3Ô∏è‚É£ ROOT CAUSES IDENTIFIED

| # | Issue | Severity | Cause |
|---|-------|----------|-------|
| A | Constraint 7 silent skip | CRITICAL | Missing else-branch: should add constraint OR error |
| B | AddBoolAnd reification | CRITICAL | Incomplete bi-directional logic |
| C | No solver timeout handling | HIGH | `UNKNOWN` status never caught |
| D | DIO+DIA bonus never activates | CRITICAL | Reification still broken |
| E | Preplan ignores constraints | CRITICAL | 4-service preplanning has NO validation |
| F | Model validation passes (FALSE POSITIVE) | CRITICAL | Validation doesn't check constraint feasibility |
| G | Rooster has 1211 "invalid" slots | CRITICAL | Status 0 indicates pre-optimization failure |

---

## 4Ô∏è‚É£ WHY IT APPEARS TO WORK (But Doesn't)

```
Current Behavior:
1. Model builds without errors (CORR-2 skips vs CORR-3 wrong)
2. Solver runs but gets UNKNOWN status
3. Code logs success anyway
4. Frontend shows "completed" 
5. Solution looks OK (because constraint 7 WAS SKIPPED)
6. But solution is INVALID when checked

Proof: 
- 1211/1470 slots have status=0 ("invalid")
- This means pre-checks detected constraint violations
- Solver DID notice something was wrong
- But code ignored the UNKNOWN status
```

---

## 5Ô∏è‚É£ CONCRETE VERBETERVOORSTELLEN

### **FIX 1: Constraint 7 - Proper Error Handling**

```python
def _constraint_7_exact_staffing(self):
    for staffing in self.required_staffing:
        team_filtered = [e for e in self.employees 
                        if e.team_id in TEAM_MAPPING[staffing.team_type]]
        
        # BEIDE CHECKS:
        eligible_emps = [e for e in team_filtered 
                        if staffing.service_id in self.employee_services.get(e.id, set())]
        
        # ‚úÖ CORRECT: ALWAYS ADD CONSTRAINT
        if eligible_emps:
            # Normal path - add constraint
            for _ in range(staffing.aantal):
                emp_var = self.model.NewIntVar(0, len(eligible_emps)-1, f"...")
                assignment_vars.append((emp_var, staffing))
        else:
            # ‚ùå INFEASIBLE PATH: MUST STILL ADD CONSTRAINT
            logger.error(f"[DRAAD169] INFEASIBLE: No employees for {staffing}")
            # Add boolean FALSE to model
            self.model.Add(self.model.NewConstant(0) == 1)  # Forces INFEASIBLE
            # Solver will correctly return INFEASIBLE status
            return False  # Signal to caller
```

**Impact:** Solver now correctly identifies impossible constraints

---

### **FIX 2: DIO+DIA Bonus - Correct Reification**

```python
def _define_objective(self):
    objective_terms = []
    
    for emp_id, dio_vars, dia_vars in self.service_combinations:
        for dt in date_range:
            dio_var = dio_vars[dt]
            dia_var = dia_vars[dt]
            
            # Create koppel variable with PROPER bi-directional constraint
            koppel_var = self.model.NewBoolVar(f"koppel_{emp_id}_{dt}")
            
            # ‚úÖ CORRECT REIFICATION:
            # koppel_var = TRUE  iff (dio_var = 1 AND dia_var = 1)
            
            # Direction 1: If koppel=TRUE then both diensten=1
            self.model.Add(dio_var == 1).OnlyEnforceIf(koppel_var)
            self.model.Add(dia_var == 1).OnlyEnforceIf(koppel_var)
            
            # Direction 2: If either dienst=0 then koppel=FALSE  
            self.model.Add(koppel_var == 0).OnlyEnforceIf(dio_var.Not())
            self.model.Add(koppel_var == 0).OnlyEnforceIf(dia_var.Not())
            
            # NOW the bonus will ACTUALLY trigger when both are assigned
            objective_terms.append(koppel_var * 500)
    
    self.model.Maximize(sum(objective_terms) + ...)
```

**Impact:** DIO+DIA bonus now truly encourages 24-hour pairings

---

### **FIX 3: Solver Status Handling**

```python
def solve(self):
    solver = cp_model.CpSolver()
    
    # Set timeout properly
    solver.parameters.max_time_in_seconds = 60
    solver.parameters.log_search_progress = True
    
    status = solver.Solve(self.model, SolutionCallback())
    
    # ‚ùå WRONG: Current code ignores UNKNOWN status
    # ‚úÖ CORRECT:
    if status == cp_model.OPTIMAL:
        logger.info("‚úÖ OPTIMAL solution found")
        return self._extract_solution(solver)
    elif status == cp_model.FEASIBLE:
        logger.warning("‚ö†Ô∏è  FEASIBLE (not optimal) - timeout likely")
        return self._extract_solution(solver)
    elif status == cp_model.INFEASIBLE:
        logger.error("‚ùå INFEASIBLE - impossible constraints")
        return {"error": "Constraints impossible", "status": 3}
    elif status == cp_model.UNKNOWN:
        logger.critical("‚ùå UNKNOWN status - timeout? memory issue?")
        return {"error": "Solver unknown state", "status": 2}
    else:
        logger.critical(f"‚ùå Unexpected status: {status}")
        return {"error": "Unknown solver error", "status": 2}
```

**Impact:** Clear error messages instead of silent failures

---

### **FIX 4: Testing & Logging**

```python
def solve(self):
    # Before solve:
    logger.info(f"[DRAAD169] Model summary:")
    logger.info(f"  - {len(self.employees)} employees")
    logger.info(f"  - {len(self.required_staffing)} staffing requirements")
    logger.info(f"  - {self.model.Proto().constraints_size} constraints")
    logger.info(f"  - Variables: {self.model.Proto().variables_size}")
    
    solver = cp_model.CpSolver()
    solver.parameters.max_time_in_seconds = 60
    solver.parameters.log_search_progress = True
    
    start = time.time()
    status = solver.Solve(self.model)
    elapsed = time.time() - start
    
    logger.info(f"[DRAAD169] Solver result:")
    logger.info(f"  - Status: {cp_model.SOLVE_STATUS_NAME[status]}")
    logger.info(f"  - Time: {elapsed:.2f}s")
    logger.info(f"  - Num conflicts: {solver.NumConflicts()}")
    logger.info(f"  - Num branches: {solver.NumBranches()}")
```

**Impact:** Clear diagnostic info for debugging

---

## 6Ô∏è‚É£ IMPLEMENTATION ROADMAP

| Phase | Task | Time | Risk |
|-------|------|------|------|
| **FASE 0** | Root cause analysis (THIS) | 30 min | None |
| **FASE 1** | Fix Constraint 7 error handling | 45 min | LOW |
| **FASE 2** | Fix DIO+DIA reification | 1 hr | MEDIUM |
| **FASE 3** | Add solver status handling | 45 min | LOW |
| **FASE 4** | Add debug logging | 30 min | NONE |
| **FASE 5** | Unit tests | 1.5 hr | LOW |
| **FASE 6** | Integration test | 30 min | MEDIUM |
| **TOTAL** | | **5 hours** | |

---

## 7Ô∏è‚É£ VOLGORDE VAN UITVOERING

1. **RAPPORTAGE** (dit document) ‚úÖ
2. **Phase 0 + 1:** Constraint 7 + error handling (KRITIEK)
3. **Phase 2:** Correct DIO+DIA reification
4. **Phase 3-6:** Logging, testing, deployment

---

## CONCLUSIE

**DRAAD 168 "fixes" zijn ONVOLLEDIG EN ONJUIST:**

- ‚ùå Constraint 7 skip-logic leidt tot silent failures
- ‚ùå AddBoolAnd reification is nog steeds broken
- ‚ùå Solver UNKNOWN status niet afgevangen
- ‚ùå Tests lijken te slagen maar valideren niets

**IMPACT:** Solver lijkt te werken, maar genereert INVALIDE roosters

**ACTIE:** Implementeer FASE 1-3 fixes VOOR productie-use
