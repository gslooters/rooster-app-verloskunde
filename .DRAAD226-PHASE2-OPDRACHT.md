# DRAAD 226 - PHASE 2: Solve Loop Engine
## Uitgebreide Implementatie-Opdracht

**Status:** üü° Voorbereiding voor VOLGENDE SESSIE  
**Datum:** 2025-12-21  
**Auteur:** AFL Implementation Framework  
**Target Fase:** STAP 2B (Phase 2: Main Planning Algorithm)

---

## üìã CONTEXT & VOORBEREIDING

### FASE 1 VOLTOOID ‚úÖ

Wat is KLAAR voor FASE 2:
- ‚úÖ `WorkbestandOpdracht[]` - Tasks in correct sort order
- ‚úÖ `WorkbestandPlanning[]` - All slots with statuses (mutable)
- ‚úÖ `WorkbestandCapaciteit[]` - Capacity per employee/service (with runtime tracking)
- ‚úÖ `WorkbestandServicesMetadata[]` - Service rules and metadata
- ‚úÖ `AflEngine` - Load engine with validation
- ‚úÖ All types defined with full TypeScript safety
- ‚úÖ Pre-planning protection: capacity adjusted for is_protected records
- ‚úÖ Performance profile: 340-470ms (meets <500ms target)

### Current Git Status

```
Branch: feat/afl-autofill-engine
Base: main
Commits Ahead: 9
Files: 4 implementation + 5 documentation
Status: Ready for Phase 2 implementation
```

### Commits Already Made

1. `.DRAAD225A-AFL-BASELINE-VERIFICATION.md` - Database check
2. `.DRAAD225-AFL-IMPLEMENTATION-PLAN.md` - Roadmap
3. `.DRAAD225-EXECUTION-STATUS.md` - Status tracking
4. `.DRAAD225-README.md` - Quick reference
5. `src/lib/afl/types.ts` - Type definitions (230+ lines)
6. `src/lib/afl/afl-engine.ts` - Load engine (350+ lines)
7. `src/lib/afl/index.ts` - Barrel export
8. `src/lib/afl/afl-engine.test.ts` - Unit tests
9. `.DRAAD225B-PHASE1-COMPLETE.md` - Phase 1 summary

---

## üéØ PHASE 2: SOLVE LOOP ENGINE

### Doel

Implement het **main planning algorithm** dat:
1. Iterates through tasks in specification order
2. Finds available employees for each task
3. Selects best employee using tiebreakers
4. Assigns service + updates workbenches
5. Handles DIO/DDO special cases (prep for Phase 3)

**Performance Target:** 3-5 seconds  
**Input:** 4 workbenches from Phase 1  
**Output:** Updated planning workbench + task invulling status

---

## üìê SPECIFICATION: FASE 2 SOLVE LOOP

### Algoritme Pseudocode (EXACT from specification)

```pseudocode
FASE 2: SOLVE LOOP
DurationTarget: 3-5 seconds

FOR each task IN workbestand_opdracht (already sorted!):
  Stap 1: Bereken hoeveel nog in te vullen
    still_needed = task.aantal - task.invulling
    IF still_needed <= 0: continue  # Skip, already done
  
  Stap 2: Bepaal team priority
    IF task.team == 'GRO':
      teams_to_try = ['GRO', 'OVERIG']
    ELSE IF task.team == 'ORA':
      teams_to_try = ['ORA', 'OVERIG']
    ELSE IF task.team == 'TOT':
      teams_to_try = ['GRO', 'ORA', 'OVERIG']  # All teams
  
  Stap 3: Bepaal dienstverband priority (only for TOT)
    IF task.team == 'TOT':
      dienstverbanden_to_try = ['Maat', 'Loondienst', 'ZZP']
    ELSE:
      dienstverbanden_to_try = [any]  # No filtering
  
  Stap 4: Vind beschikbare medewerkers
    candidates = []
    FOR each team IN teams_to_try:
      FOR each employee IN get_employees_by_team(team):
        # Check 1: Bevoegdheid (actief=TRUE)
        capacity = workbestand_capaciteit.get(
          (employee.id, task.service_id)
        )
        IF capacity is None OR !capacity.actief: continue
        
        # Check 2: Nog capaciteit
        IF capacity.aantal_beschikbaar <= 0: continue
        
        # Check 3: Beschikbaar op datedagdeel (status=0)
        slot = workbestand_planning.find(
          employee.id == task.employee_id AND
          date == task.date AND
          dagdeel == task.dagdeel AND
          status == 0  # Available
        )
        IF slot is None: continue
        
        # Candidate gefonden!
        candidates.append({
          employee_id: employee.id,
          employee_name: employee.name,
          capacity_remaining: capacity.aantal_beschikbaar,
          last_worked: get_last_worked_date(employee.id),
          team: employee.team,
          dienstverband: employee.dienstverband
        })
      
      # Don't try next team if found candidates
      IF candidates.length > 0: break
  
  Stap 5: Selecteer beste medewerker (tiebreakers!)
    IF candidates.length == 0:
      task.invulling = 0  # Mark as open
      continue  # No one available
    
    selected = select_best_employee(candidates)
      # Tiebreaker 1: Most remaining capacity
      # Tiebreaker 2: Longest time since last worked (fairness)
      # Tiebreaker 3: Alphabetical (deterministic)
  
  Stap 6: Special handling for DIO
    IF task.service_code == 'DIO':
      # DIO requires DIA on same day evening
      # Check: Is evening (dagdeel='A') available?
      
      dia_slot = workbestand_planning.find(
        selected.employee_id == X AND
        date == task.date AND
        dagdeel == 'A' AND
        status == 0
      )
      
      IF dia_slot is None:
        # Evening not available, try next candidate
        candidates.remove(selected)
        IF candidates.length > 0:
          selected = select_best_employee(candidates)
          GOTO Stap 6  # Recursive check
        ELSE:
          task.invulling = 0
          continue
      
      # Both morning and evening available
      # ASSIGN BOTH (Phase 3 will handle blocking)
      assign_dienst(selected, task.date, 'O', task.serviceid)  # DIO
      assign_dienst(selected, task.date, 'A', DIA_SERVICE_ID)   # DIA
      block_slot(selected, task.date, 'M', status=2)            # Block midday
  
  Stap 7: Special handling for DDO (identical to DIO)
    ELSE IF task.service_code == 'DDO':
      # Same logic as DIO but for DDO+DDA
      # (not shown for brevity - identical pattern)
  
  Stap 8: Regular service (RO, etc)
    ELSE:
      assign_dienst(selected, task.date, task.dagdeel, task.service_id)
  
  Stap 9: Update workbenches
    task.invulling = 1  # Mark task as filled
    decrement_capacity(selected.employee_id, task.service_id)
      # workbestand_capaciteit[...].aantal_beschikbaar -= 1

END FOR
```

---

## üõ†Ô∏è IMPLEMENTATIE PLAN

### File: `src/lib/afl/solve-engine.ts` (~400-500 lines)

#### Class: `SolveEngine`

```typescript
class SolveEngine {
  constructor(
    private planning: WorkbestandPlanning[],
    private capaciteit: WorkbestandCapaciteit[],
    private metadata: WorkbestandServicesMetadata[],
    private employees: EmployeeData[]  // Runtime employee lookup
  ) {}
  
  async solve(
    opdracht: WorkbestandOpdracht[],
    rooster_period: RoosterPeriod
  ): Promise<{
    planning_updated: WorkbestandPlanning[],
    opdracht_updated: WorkbestandOpdracht[],
    solve_duration_ms: number
  }>
  
  private find_candidates(
    task: WorkbestandOpdracht,
    teams_to_try: string[]
  ): EmployeeCandidate[]
  
  private select_best_employee(
    candidates: EmployeeCandidate[]
  ): EmployeeCandidate
  
  private assign_dienst(
    employee_id: string,
    date: Date,
    dagdeel: string,
    service_id: string
  ): void
  
  private decrement_capacity(
    employee_id: string,
    service_id: string
  ): void
  
  private check_dio_availability(
    employee_id: string,
    date: Date
  ): boolean
  
  private block_slot(
    employee_id: string,
    date: Date,
    dagdeel: string,
    status: number
  ): void
}
```

---

## üîç KRITIEKE IMPLEMENTATIE DETAILS

### 1. Team Fallback Logic

```typescript
DetermineTeamPriority(task_team: string): string[] {
  if (task_team === 'GRO') return ['GRO', 'OVERIG'];
  if (task_team === 'ORA') return ['ORA', 'OVERIG'];
  if (task_team === 'TOT') return ['GRO', 'ORA', 'OVERIG'];  // All
}
```

**CRITICAL:** Only try next team if NO candidates found in current team.

### 2. Candidate Finding (3-part Check)

Everyone must pass ALL 3 checks:

```typescript
‚úì Check 1: Qualification (actief=TRUE)
‚úì Check 2: Capacity remaining > 0
‚úì Check 3: Slot available (status=0)
```

If ANY check fails ‚Üí candidate skipped.

### 3. Tiebreaker Priority

```typescript
Tiebreaker 1: MOST REMAINING CAPACITY (descending)
  Why: Balance workload
  
Tiebreaker 2: LONGEST TIME SINCE LAST WORKED (ascending dates)
  Why: Fairness - give work to those who worked least
  Data: Calculate from previous_service_id chain
  
Tiebreaker 3: ALPHABETICAL (ascending names)
  Why: Deterministic, reproducible
```

### 4. DIO Special Case (CRITICAL)

**DIO requires BOTH:**
- Morning (O): DIO service
- Evening (A): DIA service (auto-assigned)
- Midday (M): BLOCKED (status=2)

**Check sequence:**
1. Find candidate for DIO morning
2. Check if evening available for SAME person
3. If evening NOT available ‚Üí try next candidate
4. Only assign when BOTH slots confirmed
5. Block midday as recovery

**NOT in Phase 2, but prepare:**
- Next day morning (O): will be blocked in Phase 3
- Next day midday (M): will be blocked in Phase 3

### 5. Task Invulling Tracking

```typescript
task.invulling values:
  0 = Open (not assigned)
  1 = Autofill (assigned in Phase 2)
  2 = Manual (pre-planned, skip)
```

When task filled: `task.invulling = 1`

### 6. Capacity Workbench Updates

```typescript
WorkbestandCapaciteit[employee_id, service_id].aantal_beschikbaar--
```

**CRITICAL:** Track in memory, don't update DB yet (Phase 4).

### 7. Planning Workbench Updates

For each assigned slot:

```typescript
workbestand_planning[index].status = 1  // assigned
workbestand_planning[index].service_id = task.service_id
workbestand_planning[index].source = 'autofill'
workbestand_planning[index].is_modified = true  // Mark for Phase 4
```

---

## üìä DATA STRUCTURES NEEDING BUILD

### EmployeeData (Runtime Lookup)

Build once at start of Phase 2:

```typescript
interface EmployeeData {
  employee_id: string;
  employee_name: string;
  team: string;  // Groen, Oranje, Overig
  dienstverband: string;  // Maat, Loondienst, ZZP
  last_worked: Date | null;
}

// Build from rooster_design.employee_snapshot or employees table
// (part of load from Phase 1 or add as parameter)
```

### CapacityMap (Fast Lookup)

```typescript
type CapacityKey = `${employee_id}:${service_id}`;
const capaciteit_map = new Map<CapacityKey, WorkbestandCapaciteit>();

// Fast O(1) lookups instead of O(n) array search
const cap = capaciteit_map.get(`emp-1:service-DIO`);
```

### PlanningGrid (by Date/DagDeel)

Optional optimization for faster slot finding:

```typescript
type GridKey = `${date}:${dagdeel}`;
const planning_grid = new Map<GridKey, WorkbestandPlanning[]>();

// Faster slot finding for DIO evening check
```

---

## üß™ TESTING STRATEGIE

### Unit Tests to Write (8 tests)

```typescript
1. testTeamFallbackLogic()
   - GRO ‚Üí ['GRO', 'OVERIG'] ‚úì
   - ORA ‚Üí ['ORA', 'OVERIG'] ‚úì
   - TOT ‚Üí ['GRO', 'ORA', 'OVERIG'] ‚úì

2. testCandidateFinding_AllChecks()
   - Only qualified (actief=TRUE) ‚úì
   - Only with capacity (>0) ‚úì
   - Only available slots (status=0) ‚úì

3. testTiebreakerOrder()
   - Most capacity wins ‚úì
   - If tied, last_worked wins ‚úì
   - If still tied, alphabetical wins ‚úì

4. testDIOSpecialHandling()
   - Requires both morning + evening ‚úì
   - Blocks midday ‚úì
   - Falls back if evening unavailable ‚úì

5. testCapacityDecrement()
   - Capacity decreases by 1 ‚úì
   - Never goes below 0 ‚úì

6. testTaskInvullingUpdate()
   - Marks task as filled (invulling=1) ‚úì

7. testPlanningWorkbenchMutation()
   - status updated ‚úì
   - service_id set ‚úì
   - source set to 'autofill' ‚úì
   - is_modified marked ‚úì

8. testPerformanceTarget()
   - Solves 250 tasks in <5 seconds ‚úì
```

---

## ‚öôÔ∏è INTEGRATIE MET FASE 1

### Input from Phase 1

```typescript
const load_result = await afl_engine.loadData(rooster_id);

// Pass to Phase 2:
const solver = new SolveEngine(
  load_result.workbestand_planning,
  load_result.workbestand_capaciteit,
  load_result.workbestand_services_metadata,
  employee_data  // Build from snapshot or query
);

const solve_result = await solver.solve(
  load_result.workbestand_opdracht,
  load_result.rooster_period
);
```

### Output for Phase 3

```typescript
{
  planning_updated: WorkbestandPlanning[],
    // - status updated (0‚Üí1 for assigned)
    // - service_id set
    // - is_modified flagged
    // - BUT: no blocked_by_date yet (Phase 3 sets this)
  
  opdracht_updated: WorkbestandOpdracht[],
    // - invulling updated (0‚Üí1 for filled tasks)
    // - Amount still open recorded
  
  solve_duration_ms: number
}
```

**Phase 3 will:**
- Detect DIO/DDO assignments
- Set blocked_by_date, blocked_by_dagdeel, etc
- Auto-assign DIA/DDA evening services
- Block next day (DIODDO chain)

---

## üéì KEY LEARNINGS FROM SPECIFICATION

1. **Sort Order Matters:** Tasks are PRE-SORTED in Phase 1. Phase 2 just iterates in order.

2. **Team Fallback:** Try team-specific first, fall back to OVERIG.

3. **DIO/DDO Complexity:** Not fully handled in Phase 2 - just check availability, assign both slots. Phase 3 handles blocking.

4. **Capacity Tracking:** Runtime field `aantal_beschikbaar` tracks decrements. DB field `aantal` unchanged until Phase 4 write.

5. **Tiebreaker Fairness:** Multiple employees with same team/qualification? Tiebreaker decides, making algorithm deterministic & fair.

6. **Performance:** 3-5 seconds for ~250 tasks = ~15-20ms per task. Good target for loop + candidate finding.

---

## üìù IMPLEMENTATION CHECKLIST

When starting Phase 2:

- [ ] Create `src/lib/afl/solve-engine.ts`
- [ ] Define `SolveEngine` class
- [ ] Implement `solve()` main loop
- [ ] Implement team fallback logic
- [ ] Implement candidate finding (3-part check)
- [ ] Implement tiebreaker selection
- [ ] Implement DIO special case handling
- [ ] Implement capacity decrement logic
- [ ] Implement workbench mutation (is_modified flag)
- [ ] Add performance timing
- [ ] Write 8 unit tests
- [ ] Test with mock data
- [ ] Update `index.ts` exports
- [ ] Commit with clear message
- [ ] Document with DRAAD226B completion file

---

## üîó FILE REFERENCES

### To Read Before Starting

1. `AFL-Detailed-Specification.md` - Section "FASE 2 SOLVE LOOP"
2. `src/lib/afl/types.ts` - All interface definitions
3. `src/lib/afl/afl-engine.ts` - How Phase 1 builds workbenches
4. `.DRAAD225-AFL-IMPLEMENTATION-PLAN.md` - Original plan

### Files to Modify

1. `src/lib/afl/solve-engine.ts` - CREATE (NEW)
2. `src/lib/afl/index.ts` - UPDATE (add exports)

### Files to Create

1. `.DRAAD226B-PHASE2-COMPLETE.md` - Completion report
2. `src/lib/afl/solve-engine.test.ts` - Unit tests

---

## üöÄ ESTIMATED EFFORT

| Task | Hours | Notes |
|------|-------|-------|
| Code implementation (main loop + methods) | 1.0 | Straightforward, just follow spec |
| DIO special case | 0.5 | Complex but well-specified |
| Capacity/workbench tracking | 0.3 | Simple mutations |
| Unit tests (8 tests) | 0.7 | Mock data + assertions |
| Documentation | 0.3 | Self-documenting code + comments |
| Testing with real data | 0.5 | If time allows |
| **TOTAL** | **~3.3 hours** | Could be 2.5-4.0 depending on debugging |

---

## ‚úÖ SUCCESS CRITERIA

Phase 2 is DONE when:

- [x] SolveEngine class implemented
- [x] Main solve loop working
- [x] Team fallback logic correct
- [x] Candidate finding works (3-part check)
- [x] Tiebreaker selection correct
- [x] DIO special case handled
- [x] Capacity decrements tracked
- [x] Workbench mutations marked (is_modified)
- [x] All 8 unit tests passing
- [x] Code compiles without errors
- [x] Documentation complete
- [x] Performance <5 seconds for 250 tasks
- [x] Ready to integrate with Phase 3

---

## üìû NEXT STEPS

1. **New Thread:** Start DRAAD 226 with this file
2. **Deploy Phase 1:** Merge feat/afl-autofill-engine ‚Üí main (optional but recommended)
3. **Implement Phase 2:** Follow this specification exactly
4. **Test Phase 2:** Run unit tests
5. **Continue:** Phase 3 (DIO/DDO Chains) in same thread
6. **Final:** Phases 4-5, testing, deploy

---

## üí° TIPS FOR IMPLEMENTATION

1. **Start Simple:** Get basic loop working first, then add complexity
2. **DIO Complexity:** Test DIO case separately before integrating
3. **Use Maps:** Consider CapacityMap for O(1) lookups instead of O(n) searches
4. **Track Timing:** Measure each step to identify bottlenecks
5. **Mock Data:** Create 5-10 test tasks with known outcomes
6. **Incremental:** Test with 10 tasks first, then 100, then 250
7. **Logs:** Add debug logs during development, remove for production

---

**DRAAD 226 FASE 2 - READY FOR IMPLEMENTATION** üü¢

All specification details provided. Code structure clear. Ready to start in new thread.
