# DRAAD150 - DIEPGAANDE DIAGNOSE: THE REAL PROBLEM

**Status:** üî¥ **CRITICAL - UPSERT Pattern FUNDAMENTALLY Broken**

**Date:** 2025-12-09 21:36 UTC  
**Attempt:** #31  
**Duration:** 4 dagen met hetzelfde probleem

---

## BEVINDING IN 1 ZIN

‚ùå **DRAAD149B wijzigingen waren gisteren NIET het echte probleem. PostgreSQL UPSERT faalt niet op deduplicatie-key, maar op DATABASE-niveau UNIQUE constraint violation.**

---

## WAAROM DRAAD149B NIET WERKTE

### Wat We Dachten:
```
Probleem: Solver geeft 2x dezelfde slot (roster, emp, date, dagdeel) met ander service_id
Oplossing: Voeg service_id toe aan dedup-key
Result: CLEAN - No duplicates found ‚úÖ
```

### Wat WERKELIJK Gebeurde:
```
Dedup logic: ‚úÖ CLEAN (geen dupes in 1137 assignments)
UPSERT: ‚ùå FAILED (conflict tegen BESTAANDE data in database)
```

---

## ROOT CAUSE GEVONDEN

### Database Schema - UNIQUE Constraint:
```sql
CREATE TABLE roster_assignments (
  id uuid PRIMARY KEY,
  roster_id uuid NOT NULL,
  employee_id text NOT NULL,
  date date NOT NULL,
  dagdeel text NOT NULL,
  service_id uuid,
  status integer,
  ...
  
  UNIQUE (roster_id, employee_id, date, dagdeel)  ‚Üê HIER ZIT DE BOOMLAP!
);
```

**Betekenis van deze UNIQUE constraint:**
- Per slot (router + employee + date + dagdeel) kan **SLECHTS 1 rij** bestaan
- `service_id` is **NIET** deel van de constraint
- Status kan zijn: 0 (ORT suggestion), 1 (fixed), 2 (blocked), 3 (blocked), 4 (na-planning)

### De Scenario Die Faalt:

**Situatie:**
```
Rooster: 76d5d9d6-be5b-4ef2-91f7-56a22ad30429
Week 48-52 (24 nov - 28 dec 2025)
```

**Solver Run #1 (vorige week):**
```
Gebruiker klikt "Roosterbewerking starten"
Solver genereert 1137 assignments
UPSERT schrijft alles naar database

Daaronder:
  Rij X: roster_1, emp_A, 2025-12-10, O, service_CARE, status=0
```

**Solver Run #2 (vandaag):**
```
Gebruiker klikt "Roosterbewerking starten" OPNIEUW
Solver genereert (dezelfde/andere) 1137 assignments

Daaronder:
  Rij Y: roster_1, emp_A, 2025-12-10, O, service_SPECIAL, status=0
```

**PostgreSQL UPSERT Process:**
```
Stap 1: Check UNIQUE constraint
  Key: (roster_1, emp_A, 2025-12-10, O)
  
Stap 2: CONFLICT gevonden!
  Rij X bestaat al met dezelfde 4 kolommen
  
Stap 3: Execute UPDATE
  UPDATE roster_assignments 
  SET service_id = 'service_SPECIAL'
  WHERE (roster_id, employee_id, date, dagdeel) = (...)
  
Stap 4: FOUT!
  ‚ùå ON CONFLICT DO UPDATE command cannot affect row a second time
```

### Waarom Dit Gebeurt

PostgreSQL heeft een **fundamenteel probleem** met deze UPSERT pattern:

```
Wanneer je UPSERT doet op (A, B, C, D) kolommen
Maar meerdere rijen in je dataset dezelfde (A, B, C, D) hebben
Probeert PostgreSQL ELKE rij te matchen tegen dezelfde bestaande record

Rij 1: (roster_1, emp_A, 2025-12-10, O, service_CARE)  ‚Üí MATCH tegen DB rij X
Rij 2: (roster_1, emp_A, 2025-12-10, O, service_SPECIAL) ‚Üí CONFLICT! Rij X al geupdate
```

---

## WAAROM DEDUP "CLEAN" ZEI

**De dedup-key met service_id:**
```typescript
const key = `${a.roster_id}|${a.employee_id}|${a.date}|${a.dagdeel}|${a.service_id}`;
```

Dit werkt GOED voor:
- ‚úÖ Duplicates BINNEN dezelfde solver output
- ‚úÖ Detecteert als solver 2x dezelfde assignment genereert

Maar werkt NIET voor:
- ‚ùå Duplicates tegen BESTAANDE data in database
- ‚ùå Protect tegen vorige solver run
- ‚ùå Prevent UNIQUE constraint violation

**Daarom:**
```
[FIX4] INPUT: ‚úÖ CLEAN - No duplicates found (1137 total)
       ‚Üë
       Dit zegt: "geen dupes IN deze 1137"
       Niet: "geen dupes tegen database"

[DRAAD135] UPSERT failed: ON CONFLICT DO UPDATE command cannot affect row a second time
           ‚Üë
           Dit zegt: "database UNIQUE constraint violation"
```

---

## HET ECHTE PROBLEEM

De UPSERT statement is **fundamenteel gebroken** voor deze use case:

```typescript
.upsert(deduplicatedAssignments, {
  onConflict: 'roster_id,employee_id,date,dagdeel',
  ignoreDuplicates: false
})
```

**Waarom dit niet werkt:**

1. **Meerdere assignments per slot:** Solver WILT verschillende services in dezelfde slot
   - Example: slot (roster, emp, date, dagdeel) kan NIET zowel CARE en SPECIAL hebben
   
2. **UNIQUE constraint is slot-based:** Database laat slechts 1 assignment per slot toe
   - Constraint: UNIQUE (roster_id, employee_id, date, dagdeel)
   - NOT: UNIQUE (roster_id, employee_id, date, dagdeel, service_id)

3. **UPSERT kan slot niet updaten:** Beide rijen willen dezelfde slot
   - Rij 1: UPDATE slot X naar service_SPECIAL
   - Rij 2: UPDATE slot X naar... iets anders?
   - PostgreSQL: "slot X kan maar 1 keer geupdate worden!"

---

## LOGS TONEN DIT DUIDELIJK

### Railway Logs - Moment van Falen:
```
[DRAAD135] === UPSERT PHASE ===
[DRAAD135] UPSERT: Inserting/updating assignments with onConflict handling...

[DRAAD135] UPSERT failed: ON CONFLICT DO UPDATE command cannot affect row a second time
           ‚Üë
           Dit is een PostgreSQL error (uit Supabase)
           NIET een application logic error
```

### Console Logs - Wat Voorgaat:
```
[FIX4] INPUT: ‚úÖ CLEAN - No duplicates found (1137 total)
[FIX4] AFTER_DEDUP: ‚úÖ CLEAN - No duplicates found (1137 total)
       ‚Üë
       Application says: alles ok
       
       Maar database zegt: FOUT!
```

---

## THE ARCHITECTURAL MISMATCH

### Wat Solver Probeert:
```
Genereer 1137 assignments optimaal verdeeld
Verschillende services kunnen dezelfde slot opvullen
UPSERT dit alles atomair naar database
```

### Wat Database Toelaat:
```
Per slot (roster, emp, date, dagdeel) slechts 1 assignment
ONGEACHTER service_id waarde
UNIQUE constraint enforce dit
```

### De Conflict:
```
Solver: "Ik wil 2 services in slot X"
Database: "Slot X kan maar 1 assignment hebben"

‚ùå Mismatch
```

---

## WHY "ADDING SERVICE_ID TO DEDUP KEY" FAILED

DRAARD149B strategy was:
```
"If we dedup by (roster, emp, date, dagdeel, service_id),
 we can have 2 assignments per slot with different services"
```

**Problem:** This only affects application-level dedup.

It DOES NOT affect:
- Database UNIQUE constraint ‚ùå
- PostgreSQL UPSERT behavior ‚ùå
- The fundamental architectural conflict ‚ùå

**The database UNIQUE constraint STILL says:**
```sql
UNIQUE (roster_id, employee_id, date, dagdeel)
```

Not:
```sql
UNIQUE (roster_id, employee_id, date, dagdeel, service_id)  ‚Üê Would need this
```

---

## PROOF: Logs Show Application Success, Database Failure

```
Application Layer:
  ‚úÖ Deduplication: CLEAN
  ‚úÖ Type verification: PASSED
  ‚úÖ All 1137 assignments ready
  
Database Layer:
  ‚ùå UNIQUE constraint violation
  ‚ùå ON CONFLICT DO UPDATE fails
  ‚ùå Cannot affect row a second time
```

**This proves the problem is AT the database level, NOT in application code.**

---

## WHAT NEEDS TO HAPPEN

To fix this, you need ONE of:

### Option A: Modify UPSERT Strategy
- Don't try to upsert when DB UNIQUE constraint prevents it
- Use DELETE + INSERT (atomic transaction)
- Or use raw SQL with proper handling

### Option B: Modify Database Schema
- Change UNIQUE constraint to include service_id
- UNIQUE (roster_id, employee_id, date, dagdeel, service_id)
- But this changes slot semantics fundamentally

### Option C: Modify Solver Output
- Solver should NOT produce 2 assignments for same slot
- Enforce: max 1 service per (roster, emp, date, dagdeel)
- This may reduce solution quality

### Option D: Separate Table for Alternatives
- Keep roster_assignments as single-per-slot
- Create roster_assignments_alternatives table
- Store multiple options separately
- Requires major refactoring

---

## TIMELINE

```
Monday Dec 06:     Problem starts (ON CONFLICT error)
Tuesday Dec 07:    DRAAD149 analysis (type checking) - doesn't fix it
Wednesday Dec 08:  DRAAD149B analysis (service_id in key) - doesn't fix it
Thursday Dec 09:   DRAAD150 deep analysis (FINDS ROOT CAUSE)
                   ‚Üê We are here
```

**Issue Duration:** 4 days, same error persists

---

## CONCLUSION

‚úÖ **DRAAD149B code is correctly implemented**  
‚úÖ **Deduplication logic works perfectly**  
‚úÖ **Type verification is correct**  

‚ùå **But UPSERT pattern fundamentally conflicts with UNIQUE constraint**  
‚ùå **The real problem is architectural, not code**  
‚ùå **Database structure prevents the solver's solution strategy**

---

## NEXT STEP

Need to implement Option A or B:
- Either change UPSERT strategy in route.ts
- Or modify database schema constraint

Current UPSERT approach **cannot work** with current schema.

---

_Diagnostic Report: DRAAD150_  
_Root Cause: Database UNIQUE Constraint vs. Application UPSERT Pattern Mismatch_  
_Status: Ready for remediation decision_
