# DRAAD 225 - AFL Implementation Plan

**Status:** üö´ Paused at Preparation Phase  
**Last Updated:** 2025-12-21 10:47 UTC  
**Target Completion:** 2 weeks (8.5 hours intensive)

---

## üéØ PLAN SAMENVATTING

### Fase Breakdown

| Phase | Task | Uren | Status | Notes |
|-------|------|------|--------|-------|
| **PRE** | Database baseline + GitHub | 0.5 | ‚úÖ DONE | Verification complete |
| **1** | Core module setup (5 files) | 1.5 | ‚è≥ PENDING | Node.js + Supabase setup |
| **2A** | Load Data (Phase 1) | 1.0 | ‚è≥ PENDING | Queries + sorting |
| **2B** | Solve Engine (Phase 2) | 1.5 | ‚è≥ PENDING | Main loop + tiebreakers |
| **2C** | DIO/DDO Chains (Phase 3) | 1.0 | ‚è≥ PENDING | Blocking logic |
| **2D** | Database Writer (Phase 4) | 0.5 | ‚è≥ PENDING | Batch updates |
| **2E** | Reporter (Phase 5) | 0.5 | ‚è≥ PENDING | JSON report |
| **3** | Testing + QA | 2.0 | ‚è≥ PENDING | Unit + integration tests |
| **4** | Commit + Deploy | 0.5 | ‚è≥ PENDING | Git push + Railway |
| | | **~8.5h** | | One intensive day |

---

## üìã DETAILED WORKFLOW

### STAP 1: Core Module Initialization

**Objective:** Set up project structure and dependencies

**Files to Create:**

```typescript
// src/lib/afl/types.ts
// Shared interfaces and types

// src/lib/afl/afl-engine.ts
// Main orchestrator + Phase 1 (Load)

// src/lib/afl/solve-engine.ts
// Phase 2 (Solve loop)

// src/lib/afl/dio-ddo-chains.ts
// Phase 3 (DIO/DDO blocking)

// src/lib/afl/database-writer.ts
// Phase 4 (Database updates)

// src/lib/afl/reporter.ts
// Phase 5 (Report generation)
```

**Dependencies Needed:**
- `@supabase/supabase-js` (already in project)
- `uuid` (for tracking)
- Built-in Node.js modules only

**Output:** Module structure ready for phase coding

---

### STAP 2A: Phase 1 - Load Data

**File:** `src/lib/afl/afl-engine.ts`

**Implementation:**

```typescript
interface WorkbestandOpdracht {
  roster_id: string;
  date: Date;
  dagdeel: 'O' | 'M' | 'A';
  team: 'GRO' | 'ORA' | 'TOT';
  service_id: string;
  service_code: string;
  is_system: boolean;
  aantal_nog: number;  // remaining to fill
  invulling: number;   // 0=open, 1=filled
}

interface WorkbestandPlanning {
  id: string;        // roster_assignments.id
  roster_id: string;
  employee_id: string;
  date: Date;
  dagdeel: 'O' | 'M' | 'A';
  status: 0 | 1 | 2 | 3;  // mutable
  service_id: string | null;  // mutable
  is_protected: boolean;
  blocked_by_date: Date | null;  // mutable
  blocked_by_dagdeel: string | null;  // mutable
  blocked_by_service_id: string | null;  // mutable
}

class AflEngine {
  async loadData(rosterId: string) {
    // Query 1: Tasks (roster_period_staffing_dagdelen)
    // Sort: is_system DESC, date ASC, dagdeel, team, service_code
    
    // Query 2: Planning (roster_assignments)
    
    // Query 3: Capacity (roster_employee_services)
    
    // Query 4: Metadata (service_types)
    
    // Query 5: Period (roosters)
    
    return {
      workbestand_opdracht,
      workbestand_planning,
      workbestand_capaciteit,
      workbestand_services_metadata,
      rooster_period
    };
  }
}
```

**Quality Checks:**
- [‚òê] All 5 queries execute successfully
- [‚òê] Sorting order matches specification
- [‚òê] No data corruption or filtering errors
- [‚òê] Execution time < 500ms

---

### STAP 2B: Phase 2 - Solve Loop

**File:** `src/lib/afl/solve-engine.ts`

**Implementation:**

```typescript
class SolveEngine {
  async solve(
    opdracht: WorkbestandOpdracht[],
    planning: WorkbestandPlanning[],
    capaciteit: Capaciteit[]
  ) {
    for (const taak of opdracht) {
      const still_needed = taak.aantal_nog - taak.invulling;
      if (still_needed <= 0) continue;
      
      // Step 1: Determine team priority
      const teams = this.get_teams_to_try(taak.team);
      
      // Step 2: Find candidates
      const candidates = this.find_candidates(
        teams,
        taak,
        planning,
        capaciteit
      );
      
      if (candidates.length === 0) {
        taak.invulling = 0;  // Open
        continue;
      }
      
      // Step 3: Select best
      const selected = this.select_best_employee(candidates);
      
      // Step 4: Handle DIO/DDO special cases
      if (taak.service_code === 'DIO') {
        // Must have evening slot available too
        // Block midday
        // Auto-assign DIA evening
      }
      
      // Step 5: Assign and update workbench
      this.assign_dienst(selected, taak);
      taak.invulling = 1;  // Filled
      this.decrement_capacity(selected, taak);
    }
  }
  
  select_best_employee(candidates: Candidate[]) {
    // Tiebreaker 1: Most remaining capacity
    // Tiebreaker 2: Longest time since last worked
    // Tiebreaker 3: Alphabetical (deterministic)
  }
}
```

**Quality Checks:**
- [‚òê] Loop processes all tasks in order
- [‚òê] Candidate selection follows spec tiebreakers
- [‚òê] DIO/DDO special handling correct
- [‚òê] Capacity decrements accurately
- [‚òê] Execution time 3-5 seconds

---

### STAP 2C: Phase 3 - DIO/DDO Chains

**File:** `src/lib/afl/dio-ddo-chains.ts`

**Implementation:**

```typescript
class DIODDOChainProcessor {
  processChains(
    planning: WorkbestandPlanning[],
    services_metadata: ServiceTypeMetadata[]
  ) {
    for (const assignment of planning) {
      if (assignment.status !== 1) continue;
      
      const service = services_metadata.find(
        s => s.id === assignment.service_id
      );
      
      if (!['DIO', 'DDO'].includes(service?.code)) continue;
      
      // Same day: Block midday, auto-assign evening
      this.block_same_day(assignment);
      this.assign_dia_evening(assignment);
      
      // Next day: Block morning and midday
      this.block_next_day(assignment);
    }
  }
  
  block_same_day(assignment: WorkbestandPlanning) {
    // Midday: status=2 (blocked)
    // Evening: Find DIA, assign if available, status=1
  }
  
  block_next_day(assignment: WorkbestandPlanning) {
    // Next day morning: status=2
    // Next day midday: status=2
    // Check if not beyond period end
  }
}
```

**Quality Checks:**
- [‚òê] DIO chain detection works
- [‚òê] Blocking flags set correctly
- [‚òê] DIA auto-assignment happens
- [‚òê] Next-day blocking respects period boundaries
- [‚òê] Execution time 1-2 seconds

---

### STAP 2D: Phase 4 - Database Writer

**File:** `src/lib/afl/database-writer.ts`

**Implementation:**

```typescript
class DatabaseWriter {
  async write_updates(
    rosterId: string,
    planning_updates: WorkbestandPlanning[],
    afl_run_id: string
  ) {
    // Collect changes
    const updates = planning_updates
      .filter(r => r.is_modified)
      .map(r => ({
        id: r.id,
        status: r.status,
        service_id: r.service_id,
        source: 'autofill',
        blocked_by_date: r.blocked_by_date,
        blocked_by_dagdeel: r.blocked_by_dagdeel,
        blocked_by_service_id: r.blocked_by_service_id,
        constraint_reason: r.constraint_reason || null,
        ort_run_id: afl_run_id,
        updated_at: new Date()
      }));
    
    // Batch update in transaction
    const { error } = await supabase
      .rpc('batch_update_assignments', {
        p_roster_id: rosterId,
        p_updates: updates
      });
    
    // Also update roster status
    await supabase
      .from('roosters')
      .update({ status: 'in_progress' })
      .eq('id', rosterId);
  }
}
```

**Quality Checks:**
- [‚òê] All changes collected correctly
- [‚òê] No INSERT operations (only UPDATE)
- [‚òê] Batch update syntax correct
- [‚òê] Transaction integrity
- [‚òê] Execution time < 500ms

---

### STAP 2E: Phase 5 - Reporter

**File:** `src/lib/afl/reporter.ts`

**Implementation:**

```typescript
interface AflReport {
  success: boolean;
  afl_run_id: string;
  rosterId: string;
  execution_time_ms: number;
  summary: {
    total_required: number;
    total_planned: number;
    total_open: number;
    coverage_percent: number;
    coverage_rating: 'excellent' | 'good' | 'fair' | 'poor';
  };
  planned_by_service: Array<{
    service_code: string;
    required: number;
    planned: number;
    open: number;
    completion_percent: number;
  }>;
  bottleneck_services: Array<{
    service_code: string;
    required: number;
    planned: number;
    open: number;
    reason: string;
  }>;
  // ... more fields
}

class Reporter {
  generate_report(
    opdracht: WorkbestandOpdracht[],
    planning: WorkbestandPlanning[],
    execution_time_ms: number,
    afl_run_id: string
  ): AflReport {
    // Calculate metrics
    const total_required = opdracht.reduce((sum, t) => sum + t.aantal_nog, 0);
    const total_planned = planning.filter(p => p.status === 1).length;
    
    // Return comprehensive report
  }
}
```

**Quality Checks:**
- [‚òê] All metrics calculated correctly
- [‚òê] JSON structure matches specification
- [‚òê] Bottleneck detection works (>10% open)
- [‚òê] Execution time < 200ms

---

## üë®‚Äçüö™ Testing Strategy

### Unit Tests

```
test('Phase 1: Load data correctly')
  ‚úÖ Queries return expected rows
  ‚úÖ Sorting order is correct
  ‚úÖ No data corruption

test('Phase 2: Solve loop')
  ‚úÖ Task assignment works
  ‚úÖ Tiebreakers applied correctly
  ‚úÖ Capacity tracking accurate

test('Phase 3: DIO/DDO chains')
  ‚úÖ Chain detection works
  ‚úÖ Blocking flags set
  ‚úÖ DIA auto-assignment happens

test('Phase 4: Database writes')
  ‚úÖ No INSERT operations
  ‚úÖ UPDATE syntax correct
  ‚úÖ Transaction integrity

test('Phase 5: Reporting')
  ‚úÖ Metrics calculated
  ‚úÖ JSON structure valid
```

---

## üîÆ Performance Targets

| Component | Target | Acceptable | Status |
|-----------|--------|-----------|--------|
| Phase 1 (Load) | 500ms | <1000ms | ‚è≥ Pending |
| Phase 2 (Solve) | 3-5s | <6s | ‚è≥ Pending |
| Phase 3 (Chains) | 1-2s | <3s | ‚è≥ Pending |
| Phase 4 (DB Write) | 500ms | <1s | ‚è≥ Pending |
| Phase 5 (Report) | 200ms | <500ms | ‚è≥ Pending |
| **TOTAL** | **4-7s** | **<11s** | ‚è≥ Pending |

**Coverage Target:** 87-95% (210-240 van ~250 services)

---

## üîê Commit Strategy

```bash
Commit 1: Core types + Phase 1 (Load)
Commit 2: Phase 2 (Solve Engine)
Commit 3: Phase 3 (DIO/DDO)
Commit 4: Phase 4 (Database Writer)
Commit 5: Phase 5 (Reporter)
Commit 6: Tests + Documentation
Commit 7: Final QA + Deployment
```

**Branch:** `feat/afl-autofill-engine`  
**Target:** Merge to main after testing

---

## ‚úÖ Next Steps

When ready to start code implementation:

1. Begin **STAP 2A:** Phase 1 Load Engine
2. Follow implementation checklist
3. Test after each phase
4. Document as you go
5. Commit with clear messages
6. Final deployment to Railway

---

## üìã References

- `AFL-Detailed-Specification.md` - Full specification
- `AFL-Schema-Analysis.md` - Schema verification
- `.DRAAD225A-AFL-BASELINE-VERIFICATION.md` - Baseline check

---

**Status:** Awaiting approval to proceed with STAP 2A (Phase 1 implementation)
