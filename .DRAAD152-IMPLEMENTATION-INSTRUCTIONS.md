# ðŸ”§ DRAAD152: IMPLEMENTATIE INSTRUCTIES

**Status:** ðŸŸ¢ KLAAR OM TE IMPLEMENTEREN  
**Duur:** ~5 minuten  
**Risk:** LAAG (backup wordt gemaakt)

---

## ðŸ–¥ VOORBEREIDING

### Wat Je Nodig Hebt

- [ ] Supabase account (https://supabase.com)
- [ ] Roster project (https://supabase.com/dashboard/project/rzecogncpkjfytebfkni)
- [ ] SQL Editor access
- [ ] 5 minuten time

### Controleer: Huidige Schema

Antwoord deze vragen VOORDAT je begint:

1. **Huidige constraints?**
   - Ga naar Supabase â†’ SQL Editor
   - Voer uit:
   ```sql
   SELECT constraint_name, constraint_type
   FROM information_schema.constraint_table_usage
   WHERE table_name = 'roster_assignments'
   ORDER BY constraint_name;
   ```
   - Zoek naar:
     - `roster_assignments_employee_id_key` (UNIQUE)
     - `roster_assignments_dagdeel_key` (UNIQUE)
   - Beide moeten zichtbaar zijn

2. **Hoeveel records in table?**
   ```sql
   SELECT COUNT(*) as total FROM roster_assignments;
   ```
   - Mag leeg zijn, mag vol zijn
   - Backup wordt gemaakt toch

---

## ðŸ”§ IMPLEMENTATIE (5 STAPPEN)

### Stap 1: Backup (Veiligheid)

**In Supabase SQL Editor:**

```sql
-- DRAAD152 BACKUP
-- Voer deze queries uit EERST

CREATE TABLE IF NOT EXISTS roster_assignments_backup_draad152 AS
SELECT * FROM roster_assignments;

SELECT COUNT(*) as backup_count FROM roster_assignments_backup_draad152;
```

âœ… **Check:** Aantal records = aantal origineel  
ðŸ“‹ **Noteer:** Hoeveel records gebackupped

---

### Stap 2: Verwijder Restrictieve Constraints

**In Supabase SQL Editor:**

```sql
-- DRAAD152 STEP 2: DROP CONSTRAINTS
-- Dit verwijdert de UNIQUE per column constraints

ALTER TABLE roster_assignments
DROP CONSTRAINT IF EXISTS roster_assignments_employee_id_key;

ALTER TABLE roster_assignments
DROP CONSTRAINT IF EXISTS roster_assignments_dagdeel_key;

SELECT 'Constraints dropped' as status;
```

âœ… **Check:** Beide `DROP CONSTRAINT` queries moeten slagen

---

### Stap 3: Add Composite Constraint

**In Supabase SQL Editor:**

```sql
-- DRAAD152 STEP 3: ADD COMPOSITE CONSTRAINT
-- Dit voegt de nieuwe samengestelde constraint toe

ALTER TABLE roster_assignments
ADD CONSTRAINT roster_assignments_unique_key
UNIQUE (roster_id, employee_id, date, dagdeel);

SELECT 'Composite constraint added' as status;
```

âœ… **Check:** Query slaagt zonder error

---

### Stap 4: Verify Nieuw Schema

**In Supabase SQL Editor:**

```sql
-- DRAAD152 STEP 4: VERIFY
-- Check dat het schema correct is

SELECT 
  constraint_name,
  string_agg(column_name, ', ' ORDER BY ordinal_position) as columns
FROM information_schema.key_column_usage
WHERE table_name = 'roster_assignments'
  AND constraint_type IN ('PRIMARY KEY', 'UNIQUE', 'FOREIGN KEY')
GROUP BY constraint_name, constraint_type
ORDER BY constraint_name;
```

âœ… **Expected Output:**
```
constraint_name              | columns
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
roster_assignments_pkey      | id
roster_assignments_rosterid_fk | roster_id
roster_assignments_employeeid_fk | employee_id  (FOREIGN KEY, not UNIQUE)
roster_assignments_unique_key | roster_id, employee_id, date, dagdeel  (NEW!)
```

**Kritiek:**
- [ ] Oude `employee_id_key` UNIQUE moet weg zijn
- [ ] Oude `dagdeel_key` UNIQUE moet weg zijn
- [ ] Nieuwe `unique_key` met 4 kolommen moet present zijn

---

### Stap 5: Data Integrity Check

**In Supabase SQL Editor:**

```sql
-- DRAAD152 STEP 5: DATA INTEGRITY
-- Controleer dat geen duplicates bestaan

SELECT 
  roster_id,
  employee_id,
  date,
  dagdeel,
  COUNT(*) as occurrences
FROM roster_assignments
GROUP BY roster_id, employee_id, date, dagdeel
HAVING COUNT(*) > 1;
```

âœ… **Check:** Query retourneert 0 rijen  
âš  **Probleem:** Als er rijen zijn, zie troubleshooting (onder)

---

## âœ… VERIFICATIE: ALLES OK?

**Checklist:**

- [ ] Backup gemaakt (Stap 1)
- [ ] Oude constraints verwijderd (Stap 2)
- [ ] Nieuwe constraint toegevoegd (Stap 3)
- [ ] Schema geverifieerd (Stap 4)
- [ ] Geen data duplicates (Stap 5)

âš  **ALLE checkmarks?** Ga naar volgende sectie

---

## ðŸ¤˜ SOLVER RETRY

### Na Schema Fix

1. **Open:** Dashboard (rooster applicatie)
2. **Select:** Draft roster (of create nieuw)
3. **Click:** "Roosterbewerking starten" knop
4. **Monitor:** Browser console

### Expected Flow

```
ðŸ¢ª ORT Solver starting...
   Processing constraints...
   Solving (30-35 seconds)...
âœ… ORT Status: FEASIBLE
   Assignments: 1137

[DRAAD150] === BATCH UPSERT PHASE ===
[DRAAD150] Created 1365 slot groups
[DRAAD150] Processing slot 1: roster_X|emp_A|2025-12-10|O (1 assignment)
[DRAAD150] âœ… Slot upsert successful (1 items)
[DRAAD150] Processing slot 2: roster_X|emp_A|2025-12-11|M (1 assignment)
[DRAAD150] âœ… Slot upsert successful (1 items)
... (1365 slots)
[DRAAD150] âœ… All 1365 slots UPSERT successful (234ms)
âœ… Roster status: draft â†’ in_progress
âœ… SUCCESS!
```

---

## ðŸš§ TROUBLESHOOTING

### Problem: "constraint roster_assignments_unique_key already exists"

**Oorzaak:** Schema fix is al eerder uitgevoerd

**Oplossing:**
```sql
-- Check of constraint al bestaat
SELECT constraint_name 
FROM information_schema.table_constraints
WHERE table_name = 'roster_assignments'
  AND constraint_name = 'roster_assignments_unique_key';

-- Constraint already exists = OK!
-- Ga door met Solver Retry
```

---

### Problem: "DROP CONSTRAINT failed - no such constraint"

**Oorzaak:** Constraint naam is anders (database schema variation)

**Oplossing:**
```sql
-- List alle constraints
SELECT constraint_name
FROM information_schema.table_constraints
WHERE table_name = 'roster_assignments';

-- Zoek naar UNIQUE constraints met "employee_id" of "dagdeel"
-- Noteer de exacte naam
-- Gebruik die naam in DROP command

ALTER TABLE roster_assignments
DROP CONSTRAINT <exact_constraint_name>;
```

---

### Problem: "Duplicate key violation after DROP"

**Oorzaak:** Er zijn duplicates in data die het oude schema toestond

**Oplossing:**
```sql
-- Vind duplicates
SELECT 
  roster_id, employee_id, date, dagdeel,
  COUNT(*) as count
FROM roster_assignments
GROUP BY roster_id, employee_id, date, dagdeel
HAVING COUNT(*) > 1;

-- Verwijder duplicates (keep first, delete rest)
DELETE FROM roster_assignments
WHERE id NOT IN (
  SELECT DISTINCT ON (roster_id, employee_id, date, dagdeel) id
  FROM roster_assignments
  ORDER BY roster_id, employee_id, date, dagdeel, created_at
);

-- Retry ADD CONSTRAINT
ALTER TABLE roster_assignments
ADD CONSTRAINT roster_assignments_unique_key
UNIQUE (roster_id, employee_id, date, dagdeel);
```

---

### Problem: Solver still fails after schema fix

**Oorzaak:** Constraint gecreeerd maar iets ander wrong

**Oplossing:**
1. **Check Railway logs:**
   - Zoek naar `[DRAAD150] Slot upsert failed` errors
   - Noteer exact error message

2. **Open GitHub Issue** met:
   - Exact error message
   - Screenshots van logs
   - Timestamp van failure

---

## ðŸŽ† SUCCESS INDICATORS

Wanneer weet je dat het werkend is?

âœ… **In Console:**
```
[DRAAD150] âœ… All 1365 slots UPSERT successful
```

âœ… **In Dashboard:**
- Roster status changed to "in_progress"
- No error message shown
- Suggested assignments visible in grid

âœ… **In Supabase:**
```sql
SELECT COUNT(*) FROM roster_assignments 
WHERE roster_id = '<your_roster_id>';
-- Should show 1137 or similar
```

---

## ðŸ“š SUMMARY

**Wat je doet:**
1. Backup maken
2. Oude restrictieve constraints verwijderen
3. Nieuwe composite constraint toevoegen
4. VerifiÃ«ren dat alles OK is
5. Solver retry

**Waarom het werkt:**
- Oude constraints: UNIQUE per kolom â†’ max 1 assignment per employee
- Nieuwe constraint: UNIQUE per combo â†’ multiple assignments per employee OK
- ORT solver output nu correct in database opgeslagen

**Tijd:** 5-10 minuten

**Risk:** LAAG (backup wordt gemaakt, alleen constraints aangepast)

---

ðŸŒŸ **Let's Fix This!** ðŸŒŸ

Vragen? GitHub issue aanmaken.
